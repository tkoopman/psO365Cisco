<#
.SYNOPSIS
  Compare current Cisco config lines with O365 Subnets.
.DESCRIPTION
  Can be used to create and maintain static routes or IP Prefix Lists for all O365 Subnets
.PARAMETER CiscoCommand
  A string expression used against all O365 subnets to generate config.
  Can contain any of the following variables. ($Network, $Subnet, $Bitmask)
  Should be surrounded by single quotes not double.
.PARAMETER CurrentConfig
  The current Cisco config commands.
  Should be filtered to only those lines generated by the output of this command.
  Don't specify to generate initial config.
.EXAMPLE
  Get-Content .\CurrentConfig.txt | select-string -pattern "name O365-DIRECT-ROUTE" | Compare-O365SubnetsToCiscoCommands -CiscoCommand 'ip route $Network $Subnet Gi0/1 10.1.1.1 name O365-DIRECT-ROUTE'
.EXAMPLE
  Get-Content .\CurrentConfig.txt | select-string -pattern "ip prefix-list allowed-routes-from-o365" | ForEach-Object { $_ -replace "seq \d+ ", "" } | Compare-O365SubnetsToCiscoCommands -CiscoCommand 'ip prefix-list allowed-routes-from-o365 permit $Network/$Bitmask'
#>
function Compare-O365SubnetsToCiscoCommands {
	[CmdletBinding()]
	param(
		[Parameter(Mandatory=$true)]
		[string]$CiscoCommand,
		[Parameter(ValueFromPipeline=$true)]
		[string[]]$CurrentConfig
	)
	BEGIN {
		# Download Microsoft Cloud IP Ranges and Names into Object
		$O365IPAddresses = "https://support.content.office.net/en-us/static/O365IPAddresses.xml";
		[XML]$O365 = Invoke-WebRequest -Uri $O365IPAddresses -DisableKeepAlive;

		# Extract ALL IPv4 unique subnets
		$O365IPs =  $O365.products.product.addresslist |
						Where-Object { ($_.type -eq "IPv4") } |
						Select-Object -ExpandProperty address -ErrorAction SilentlyContinue |
						Sort-Object -Unique;

		# Generate what the config should look like
		$O365Config = foreach($IP in $O365IPs) {
			$Split = $IP.Split('/');
			$Network = $Split[0];
			$Bitmask = [int]$Split[1];
			if (-not $Bitmask) { $Bitmask = 32; }
			$Subnet = ConvertTo-Mask $Bitmask;

			Invoke-Expression "Write-Output `"$CiscoCommand`"";
		}

		$Script:Config = @();
	}

	PROCESS {
		# Get all current config into single variable
		$Script:Config += $CurrentConfig
	}

	END {
		if ($Script:Config.Length -gt 0) {
			Write-Verbose "Comparing O365 routes to Current"
			$Results = Compare-Object -ReferenceObject $Script:Config -DifferenceObject $O365Config

			# Output config lines to be added
			$Results | Where-Object { $_.SideIndicator -eq "=>" } | Select-Object -ExpandProperty InputObject

			# Output config lines to be removed
			$Results | Where-Object { $_.SideIndicator -eq "<=" } | Select-Object -ExpandProperty InputObject | ForEach-Object { "no $_" }
		} else {
			# If no current config just output all config lines
			$O365Config
		}
	}
}

<#
.SYNOPSIS
  Gets current running config from Cisco device via SSH.
.DESCRIPTION

.PARAMETER ComputerName
  Cisco device to connect to.
.PARAMETER Credential
  Login credential to use. To work this credential should take you into enable mode automatically.
#>
function Get-CiscoRunningConfig {
	[CmdletBinding()]
	param(
		[Parameter(Mandatory=$true)]
		[string]$ComputerName,
		[Parameter(Mandatory=$true)]
		[PSCredential]$Credential
	)

	PROCESS {
		$SSHSession = New-SSHSession -ComputerName $ComputerName -Credential $Credential -AcceptKey;
		$SSHShell = New-SSHShellStream -SSHSession $SSHSession -TerminalName xterm -Columns 1000 -Rows 1000 -Width 1000 -Height 1000 -BufferSize 1000;

		# Read initial session data looking for enable prompt
		$Output = Read-CiscoStream -SSHShell $SSHShell -Prompt "#";

		# Get full prompt
		$Prompt = $Output[-1];
		
		$SSHShell.WriteLine("term len 0");

		$SSHShell.WriteLine("show running-config");
		$Output = Read-CiscoStream -SSHShell $SSHShell -Prompt $Prompt;

		# Remove command echo and prompt
		$Output  | Where-Object { $_ -ne "show running-config" -and $_ -ne $Prompt };

		Remove-SSHSession -SSHSession $SSHSession | Out-Null
	}
}

<#
.SYNOPSIS
  Reads data from SSH stream until either expected prompt is found or max timeout is reached.
.DESCRIPTION

.PARAMETER SSHShell
  SSH Shell Stream to read from.
.PARAMETER Prompt
  Expected string that should be the last data read to stop looking for more.
.PARAMETER MaxWait
  Max number of seconds to wait for prompt.
#>
function Read-CiscoStream {
	[CmdletBinding()]
	param(
		[Parameter(Mandatory=$true)]
		[Renci.SshNet.ShellStream]$SSHShell,
		[string]$Prompt,
		[int]$MaxWait = 20
	)

	PROCESS {
		$Output = "";
		$StopWatch = [system.diagnostics.stopwatch]::StartNew();
		while ($true) {
			if ($SSHShell.DataAvailable) { $Output += $SSHShell.Read(); }
			if ($StopWatch.Elapsed.Seconds -gt $MaxWait) {
				# Max timeout reached
				Write-Verbose "Read-CiscoStream stopped due to max timeout reached!";
				break;
			}
			Start-Sleep -Milliseconds 100
			if (-not $SSHShell.DataAvailable) {
				if ($Prompt) {
					if ($Output.EndsWith($Prompt)) {
						# No more pending data and last bit of data was expected prompt
						break;
					}
				} else {
					# No more data and not looking for specific prompt
					break;
				}
			}
		}

		$StopWatch.Stop();

		$Output -split "[\r\n]" |? {$_};
	}
}

function ConvertTo-DottedDecimalIP {
  <#
    .Synopsis
      Returns a dotted decimal IP address from an unsigned 32-bit integer.
    .Description
    .Parameter IPAddress
      A string representation of an IP address from UInt32.
  #>

  [CmdLetBinding()]
  param(
    [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
    [String]$IPAddress
  )

  process {
    $IPAddress = [UInt32]$IPAddress
    $DottedIP = $( For ($i = 3; $i -gt -1; $i--) {
        $Remainder = $IPAddress % [Math]::Pow(256, $i)
        ($IPAddress - $Remainder) / [Math]::Pow(256, $i)
        $IPAddress = $Remainder
        } )

	return [String]::Join('.', $DottedIP)
  }
}

function ConvertTo-Mask {
  <#
    .Synopsis
      Returns a dotted decimal subnet mask from a mask length.
    .Description
      ConvertTo-Mask returns a subnet mask in dotted decimal format from an integer value ranging
      between 0 and 32. ConvertTo-Mask first creates a binary string from the length, converts
      that to an unsigned 32-bit integer then calls ConvertTo-DottedDecimalIP to complete the operation.
    .Parameter MaskLength
      The number of bits which must be masked.
  #>

  [CmdLetBinding()]
  param(
    [Parameter(Mandatory = $true, Position = 0, ValueFromPipeline = $true)]
    [Alias("Length")]
    [ValidateRange(0, 32)]
    $MaskLength
  )

  Process {
    return ConvertTo-DottedDecimalIP ([Convert]::ToUInt32($(("1" * $MaskLength).PadRight(32, "0")), 2))
  }
}